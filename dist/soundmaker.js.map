{
  "version": 3,
  "sources": ["../src/ADSREnvelope.ts", "../src/utils.ts", "../src/NodeFactory.ts", "../src/soundmaker.ts"],
  "sourcesContent": ["import { ExtendedAudioParam } from \"./types\";\r\n\r\ninterface ADSR {\r\n    attack:       number;\r\n    sustain:      number;\r\n    decay:        number;\r\n    release:      number;\r\n    sustainLevel: number;\r\n};\r\n\r\nexport class ADSREnvelope implements ADSR {\r\n    \r\n    attack: number;\r\n    sustain: number;\r\n    decay: number;\r\n    release: number;\r\n    sustainLevel: number;\r\n    id: string;\r\n    \r\n    constructor(){\r\n        this.attack = 0;\r\n        this.sustain = 0;\r\n        this.decay = 0;\r\n        this.release = 0;\r\n        this.sustainLevel = 0;\r\n        this.id = \"\";\r\n    }\r\n\r\n    updateParams(params: ADSR){\r\n        for(let param in params){\r\n            if(param in this){\r\n                this[param as keyof ADSR] = params[param as keyof ADSR];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // need a type for targetNodeParam\r\n    applyADSR(targetNodeParam: ExtendedAudioParam, start: number){\r\n        // targetNodeParam might be the gain property of a gain node, or a filter node for example\r\n        // the targetNode just needs to have fields that make sense to be manipulated with ADSR\r\n        // i.e. pass in gain.gain as targetNodeParam\r\n        \r\n        // only assuming node params that are objects (and have a value field)\r\n        const baseParamVal = targetNodeParam.baseValue; // i.e. gain.gain.value. this value will be the max value that the ADSR envelope will cover (the peak of the amplitude)\r\n\r\n        // sustainLevel should be the level that the ADSR drops off to after hitting the peak, which is baseParamVal\r\n        const sustainLevel = this.sustainLevel === 0 ? 1 : this.sustainLevel;\r\n        targetNodeParam.cancelAndHoldAtTime(start);\r\n        targetNodeParam.linearRampToValueAtTime(0.0, start);\r\n        targetNodeParam.linearRampToValueAtTime(baseParamVal, start + this.attack);\r\n        targetNodeParam.linearRampToValueAtTime(baseParamVal * sustainLevel, start + this.attack + this.decay);\r\n        targetNodeParam.linearRampToValueAtTime(baseParamVal * sustainLevel, start + this.attack + this.decay + this.sustain);\r\n        \r\n        return targetNodeParam;\r\n    }\r\n}", "import { NodeFactory } from \"./NodeFactory\";\r\nimport { \r\n    AudioStoreNode, \r\n    AudioBufferParameters,\r\n    ExtendedAudioBufferSourceNode\r\n} from \"./types\";\r\n\r\n/***\r\n\r\n    UI stuff\r\n\r\n***/\r\nexport function drawLineBetween(htmlElement1: HTMLElement, htmlElement2: HTMLElement, dash=false){\r\n    \r\n    const svgLine = document.getElementById(\"svgCanvas:\" + htmlElement1.id + \":\" + htmlElement2.id);\r\n    if(svgLine){\r\n        // not sure why yet that duplicate line svgs are being created but they are and this should\r\n        // prevent that\r\n        return;\r\n    }\r\n    \r\n    // instead, we should create an individual svg per line\r\n    let svg = document.getElementById(\"svgCanvas\");\r\n    \r\n    if(svg === null){\r\n        // TODO: solve TS2740?\r\n        // @ts-ignore\r\n        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        svg!.style.position = \"absolute\";\r\n        svg!.id = \"svgCanvas:\" + htmlElement1.id + \":\" + htmlElement2.id;\r\n        svg!.style.zIndex = \"0\";\r\n        svg!.style.height = \"1000px\"; // calculate these after you calculate the line dimensions?\r\n        svg!.style.width = \"1000px\";    // calculate these after you calculate the line dimensions?\r\n        \r\n        document.getElementById('nodeArea')!.appendChild(svg!);\r\n    }\r\n    \r\n    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\r\n    if(line !== null){\r\n        line.classList.add('line');\r\n        line.setAttribute('stroke', '#000');\r\n        line.setAttribute('stroke-width', '1px');\r\n    }\r\n    \r\n    if(dash){\r\n        // for dotted lines\r\n        line.setAttribute('stroke-dasharray', \"10\");\r\n    }\r\n    \r\n    const element1x = htmlElement1.offsetLeft + document.body.scrollLeft + ((htmlElement1.offsetWidth)/2);\r\n    const element1y = htmlElement1.offsetTop + document.body.scrollTop + ((htmlElement1.offsetHeight)/2);\r\n    const element2x = htmlElement2.offsetLeft + document.body.scrollLeft + ((htmlElement2.offsetWidth)/2);\r\n    const element2y = htmlElement2.offsetTop + document.body.scrollTop + ((htmlElement2.offsetHeight)/2);\r\n    \r\n    if(svg !== null && line !== null){\r\n        line.setAttribute('x1', String(element1x));\r\n        line.setAttribute('y1', String(element1y));\r\n        line.setAttribute('x2', String(element2x));\r\n        line.setAttribute('y2', String(element2y));\r\n        \r\n        const maxWidth = Math.max(element1x, element2x) + 200;\r\n        const maxHeight = Math.max(element1y, element2y) + 200;\r\n        svg.style.height = parseInt(svg.style.height) < maxHeight ? (maxHeight + \"px\") : svg.style.height;\r\n        svg.style.width = parseInt(svg.style.width) < maxWidth ? (maxWidth + \"px\") : svg.style.width;\r\n        \r\n        svg.appendChild(line);\r\n    }\r\n}\r\n\r\nexport function showParameterEditWindow(nodeInfo: AudioStoreNode, valueRanges: any){\r\n    const editWindow = document.getElementById(\"editNode\");\r\n    if(editWindow === null) return;\r\n    \r\n    editWindow.style.display = \"block\";\r\n    \r\n    while(editWindow.firstChild){\r\n        editWindow.removeChild(editWindow.firstChild);\r\n    }\r\n    const title = document.createElement(\"h3\");\r\n    title.textContent = nodeInfo.node.id;\r\n    editWindow.appendChild(title);\r\n    \r\n    const node = nodeInfo.node;\r\n    let customizableProperties = Object.keys(Object.getPrototypeOf(nodeInfo.node));\r\n\r\n    if(customizableProperties.length === 0){\r\n        // i.e. for adsr envelope \r\n        customizableProperties = Object.keys(nodeInfo.node).filter((prop) => typeof(nodeInfo.node[prop]) === \"number\");\r\n    }\r\n\r\n    customizableProperties.forEach((prop) => {\r\n        const propertyDiv = document.createElement('div');\r\n        propertyDiv.style.display = \"inline-block\";\r\n        propertyDiv.style.marginRight = \"3%\";\r\n        propertyDiv.style.marginLeft = \"3%\";\r\n        \r\n        const property = document.createElement('p');\r\n        propertyDiv.appendChild(property);\r\n        \r\n        let text = prop;\r\n        let isNumValue = false;\r\n        if(node[prop].value !== undefined){\r\n            text += \".value\";\r\n            isNumValue = true;\r\n        }else if(typeof(node[prop]) === \"number\"){\r\n            isNumValue = true;\r\n        }\r\n        \r\n        property.textContent = text; // the name of the parameter to be edited\r\n\r\n        if(isNumValue){\r\n            editWindow.appendChild(propertyDiv);\r\n            \r\n            // what kind of param is it \r\n            // probably should refactor this. instead, make sure each NODE INSTANCE has some new field called 'nodeType' that we can use?\r\n            let props = valueRanges[node.constructor.name] || valueRanges[node.type];\r\n            props = props[prop];\r\n            \r\n            const slider = document.createElement('input');\r\n            slider.id = text;\r\n            slider.setAttribute('type', 'range');\r\n            slider.setAttribute('max', props ? props['max'] : 0.5);\r\n            slider.setAttribute('min', props ? props['min'] : 0.0);\r\n            slider.setAttribute('step', props ? props['step'] : 0.01);\r\n            \r\n            // also allow value input via text edit box \r\n            const editBox = document.createElement('input');\r\n            editBox.id = text + '-edit';\r\n            editBox.setAttribute('size', \"6\");\r\n            editBox.setAttribute('type', 'text');\r\n            \r\n            if(node[prop].value){\r\n                // use the base value, which is the current user-desired value, \r\n                // not the actual current value (i.e. for gain)\r\n                slider.setAttribute('value', node[prop].baseValue);\r\n            }else if(typeof(node[prop]) === \"number\"){\r\n                // relevant to the ADSR envelope\r\n                slider.setAttribute('value', node[prop]);\r\n            }else{\r\n                slider.setAttribute('value', props['default']);\r\n            }\r\n            \r\n            editBox.value = slider.getAttribute('value') || \"\";\r\n            editBox.style.fontFamily = \"monospace\";\r\n            editBox.addEventListener('input', (evt) => {\r\n                // evaluate the new value. \r\n                // if it's a valid value, update the param it belongs to.\r\n                const inputtedValue = parseFloat((<HTMLInputElement>evt.target).value);\r\n                const sliderMinVal = slider.getAttribute('min');\r\n                const sliderMaxVal = slider.getAttribute('max');\r\n                \r\n                if(sliderMinVal && sliderMaxVal &&\r\n                   inputtedValue >= parseFloat(sliderMinVal) &&\r\n                    inputtedValue <= parseFloat(sliderMaxVal)){\r\n                        slider.setAttribute('value', (inputtedValue).toString());\r\n                        \r\n                        if(node[prop].value !== undefined){\r\n                            node[prop].value = inputtedValue;\r\n                            // also add it as a desired param value in a separate property\r\n                            // this is so that if we're working with an ADSR envelope on a gain node\r\n                            // we know the desired base value. we shouldn't rely on the actual value param to know that\r\n                            // since that will be variable and subject to change.\r\n                            node[prop].baseValue = inputtedValue;\r\n                        }else{\r\n                            node[prop] = inputtedValue;\r\n                        }\r\n                }                \r\n            });\r\n            \r\n            slider.addEventListener('input', function(evt){\r\n                const newVal = parseFloat((<HTMLInputElement>evt.target).value);\r\n                editBox.value = (newVal).toString();\r\n                \r\n                // update node\r\n                if(node[prop].value !== undefined){\r\n                    node[prop].value = newVal;\r\n                    node[prop].baseValue = newVal;\r\n                }else{\r\n                    node[prop] = newVal;\r\n                }\r\n            });\r\n            \r\n            propertyDiv.appendChild(slider);\r\n            propertyDiv.appendChild(editBox);\r\n        }else{\r\n            if(prop === \"type\"){\r\n                // dropdown box for type\r\n                editWindow.appendChild(propertyDiv);\r\n                \r\n                const dropdown = document.createElement('select');\r\n                dropdown.id = text + \"Type\";\r\n                \r\n                let options = [];\r\n                if(node.constructor.name.indexOf(\"Oscillator\") >= 0){\r\n                    // use waveType\r\n                    options = valueRanges[\"waveType\"];\r\n                }else{\r\n                    // use filterType\r\n                    options = valueRanges[\"filterType\"];\r\n                }\r\n                options.forEach((opt: string) => {\r\n                    const option = document.createElement('option');\r\n                    option.textContent = opt;\r\n                    dropdown.appendChild(option);\r\n                });\r\n                dropdown.addEventListener('change', (evt) => {\r\n                    const val = dropdown.options[dropdown.selectedIndex].value;\r\n                    nodeInfo.node[prop] = val;\r\n                });\r\n                dropdown.value = node[prop];\r\n                propertyDiv.appendChild(dropdown);\r\n            }\r\n        }\r\n    });\r\n    \r\n    // allow user to close param edit window\r\n    const hideWindow = document.createElement('p');\r\n    hideWindow.style.margin = \"0 auto\";\r\n    hideWindow.style.marginTop = \"2%\";\r\n    hideWindow.style.width = \"3%\";\r\n    hideWindow.textContent = 'close';\r\n    hideWindow.style.color = \"#ff0000\";\r\n    hideWindow.addEventListener('click', (evt) => {\r\n        editWindow.style.display = \"none\";\r\n    });\r\n    \r\n    editWindow.appendChild(hideWindow);\r\n}\r\n\r\n\r\n/***\r\n\r\n    loading/exporting presets\r\n\r\n***/\r\n\r\n// import preset \r\nexport function importPreset(nodeFactory: NodeFactory){\r\n    const input = document.getElementById('importInstrumentPresetInput');\r\n    if(input !== null){\r\n        input.addEventListener('change', importInstrumentPreset(nodeFactory), false);\r\n        input.click();\r\n    }\r\n}\r\n\r\n// TODO: make an interface for data parameter?\r\nfunction processPresetImport(data: any, nodeFactory: NodeFactory){\r\n    // clear out current nodes\r\n    nodeFactory.reset();\r\n    \r\n    // remove all svg lines\r\n    const svgLines = document.querySelectorAll('line');\r\n    if(svgLines){\r\n        svgLines.forEach(el => el.parentNode!.removeChild(el));\r\n    }\r\n    \r\n    // add new nodes\r\n    for(let nodeId in data){\r\n        if(nodeId.indexOf(\"Gain\") > -1){\r\n            // gain node\r\n            nodeFactory.addNewNode(\"gainNode\");\r\n        }else if(nodeId.indexOf(\"Oscillator\") > -1){\r\n            // oscillator node\r\n            nodeFactory.addNewNode(\"waveNode\");\r\n        }else if(nodeId.indexOf(\"ADSR\") > -1){\r\n            // ADSR envelope\r\n            nodeFactory.addNewNode(\"ADSREnvelope\");\r\n        }else if(nodeId.indexOf(\"AudioBuffer\") > -1){\r\n            // audio buffer node\r\n            nodeFactory.addNewNode(\"noiseNode\");\r\n        }else if(nodeId.indexOf(\"BiquadFilter\") > -1){\r\n            // biquad filter node\r\n            nodeFactory.addNewNode(\"biquadFilterNode\");\r\n        }\r\n        \r\n        if(nodeId !== \"AudioDestinationNode\"){\r\n            let node = nodeFactory.nodeStore[nodeId];\r\n            node.feedsInto = data[nodeId].feedsInto;\r\n            node.feedsFrom = data[nodeId].feedsFrom;\r\n            \r\n            // update params based on saved values\r\n            let params = data[nodeId].node;\r\n            \r\n            if(\"buffer\" in params){\r\n                // need to create a new audiobuffersource node instance\r\n                if(params[\"buffer\"].channelData){\r\n                    // create a new audiobuffer object that will be added to the source node instance\r\n                    const bufferData = new Float32Array([...Object.values(params[\"buffer\"].channelData) as number[]]); \r\n                    delete params[\"buffer\"]['duration']; // duration param not supported for constructor apparently\r\n                    \r\n                    const buffer = new AudioBuffer(params[\"buffer\"]);\r\n                    buffer.copyToChannel(bufferData, 0); // only one channel. TODO: does this need to be changed?\r\n                    params[\"buffer\"] = buffer;\r\n                }\r\n                \r\n                const newAudioBuffSource = new AudioBufferSourceNode(nodeFactory, params) as ExtendedAudioBufferSourceNode;\r\n                newAudioBuffSource.loop = true;\r\n                newAudioBuffSource.id = nodeId;\r\n                node.node = newAudioBuffSource;\r\n            }else{\r\n                for(let param in params){\r\n                    if(node.node[param].value !== undefined){\r\n                        node.node[param].value = params[param];\r\n                        node.node[param].baseValue = params[param];\r\n                    }else if(param in node.node){\r\n                        node.node[param] = params[param];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // connect nodes in UI with svg lines\r\n    // also offset the nodes in the UI a bit so the user can see that they were all loaded\r\n    // otherwise they're stacked perfectly on each other and it looks like there's only a single node\r\n    for(let nodeId in data){\r\n        const node = nodeFactory.nodeStore[nodeId];\r\n        node.feedsInto.forEach((sinkId) => {\r\n            const source = document.getElementById(nodeId);\r\n            if(source !== null){\r\n                // offset source node UI slightly\r\n                const maxTop = parseInt(source.style.top) + 80;\r\n                const minTop = parseInt(source.style.top) - 80;\r\n                source.style.top = (Math.random() * (maxTop - minTop) + minTop) + \"px\";\r\n                \r\n                const maxLeft = parseInt(source.style.left) + 80;\r\n                const minLeft = parseInt(source.style.left) - 80;\r\n                source.style.left = (Math.random() * (maxLeft - minLeft) + minLeft) + \"px\";\r\n                \r\n                const sink = document.getElementById(sinkId);\r\n                const line = document.getElementById(\"svgCanvas:\" + nodeId + \":\" + sinkId);\r\n                \r\n                // make sure line doesn't exist already\r\n                if(line !== null && sink !== null){\r\n                    if(nodeId.indexOf(\"ADSR\") > -1){\r\n                        drawLineBetween(source, sink, true);\r\n                    }else{\r\n                        drawLineBetween(source, sink, false);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }    \r\n}\r\n\r\nfunction importInstrumentPreset(nodeFactory: NodeFactory){\r\n    return (function(nf){\r\n        return function(evt: Event){\r\n            const reader = new FileReader();\r\n            const file = (<HTMLInputElement>evt.target).files![0];\r\n            \r\n            reader.onload = (function(theFile){\r\n                return function(e){\r\n                    const json = JSON.parse(reader.result as string);\r\n                    if(json['data']){\r\n                        processPresetImport(json['data'], nf);\r\n                    }\r\n                }\r\n            })(file);\r\n\r\n            reader.readAsText(file);\r\n        }\r\n    })(nodeFactory);\r\n}\r\n\r\nexport function exportPreset(nodeFactory: NodeFactory){\r\n    const fileName = prompt(\"enter filename\");\r\n    if(fileName === null || fileName === \"\"){\r\n        return;\r\n    }\r\n    \r\n    const objToExport: Record<string, any> = {}; // TODO: make be not any\r\n    const currNodeStore = nodeFactory.nodeStore;\r\n    const currNodeStoreKeys = Object.keys(currNodeStore);\r\n    currNodeStoreKeys.forEach((node: string) => {\r\n        const currNode = currNodeStore[node];\r\n        \r\n        const nodeProps = {\r\n            id: currNode.node.id,\r\n            node: {},\r\n            feedsFrom: currNode.feedsFrom,\r\n            feedsInto: currNode.feedsInto,\r\n        };\r\n        \r\n        let params = Object.keys(Object.getPrototypeOf(currNode.node));\r\n        if(params.length === 0){\r\n            // i.e. for ADSREnvelope, which is just a regular object\r\n            params = Object.keys(currNode.node);\r\n        }\r\n        \r\n        const nodeParams: Record<string, any> = {};\r\n        params.forEach((param) => {\r\n            if(typeof(currNode.node[param]) === \"object\" && \"value\" in currNode.node[param]){\r\n                // should just test value type instead? i.e. number vs string? if num, use value property?\r\n                nodeParams[param] = currNode.node[param].value;\r\n            }else if(currNode.node[param].constructor.name === \"AudioBuffer\"){\r\n                // handle audio buffers specially\r\n                const buffer: AudioBuffer = currNode.node[param];\r\n                const bufferProps: AudioBufferParameters = {\r\n                    duration: buffer.duration,\r\n                    length: buffer.length,\r\n                    numberOfChannels: buffer.numberOfChannels,\r\n                    sampleRate: buffer.sampleRate,\r\n                    channelData: buffer.getChannelData(0)\r\n                };\r\n                nodeParams[param] = bufferProps;\r\n            }else{\r\n                // single value for this param \r\n                nodeParams[param] = currNode.node[param];\r\n            }\r\n        });\r\n        nodeProps.node = nodeParams;\r\n        \r\n        objToExport[node] = nodeProps;\r\n    });\r\n    \r\n    const theData = {\r\n        \"name\": fileName,\r\n        \"data\": objToExport\r\n    };\r\n    \r\n    const blob = new Blob([JSON.stringify(theData, null, 2)], {type: \"application/json\"});\r\n    const url = URL.createObjectURL(blob);\r\n    const link = document.createElement('a');\r\n    link.href = url;\r\n    link.download = fileName + \".json\";\r\n    link.click();\r\n}\r\n\r\nexport function loadDemoPreset(presetName: string, nodeFactory: NodeFactory){\r\n    fetch(\"demo-presets/\" + presetName + \".json\")\r\n        .then(response => response.json())\r\n        .then(data => {\r\n            processPresetImport(data.data, nodeFactory);\r\n        });\r\n}", "import { ADSREnvelope } from \"./ADSREnvelope\";\r\nimport {\r\n    ExtendedOscillatorNode,\r\n    ExtendedAudioBufferSourceNode,\r\n    ExtendedBiquadFilterNode,\r\n    ExtendedGainNode,\r\n    ExtendedAudioParam,\r\n    AudioStoreNode,\r\n    NodeTypes,\r\n} from \"./types\";\r\nimport {\r\n    drawLineBetween,\r\n    showParameterEditWindow\r\n} from \"./utils\";\r\n\r\n\r\nexport class NodeFactory extends AudioContext {\r\n    \r\n    nodeColors: Record<string, string>;\r\n    nodeStore: Record<string, AudioStoreNode>; // TODO: something more specific than any\r\n    nodeCounts: Record<string, any>; // TODO: this too?\r\n    valueRanges: Record<string, any>;\r\n    analyserNode: any;\r\n    \r\n    constructor(){\r\n        super();\r\n        \r\n        this.nodeColors = {}; // different background color for each kind of node element?\r\n        this.nodeStore = {};  // store refs for nodes\r\n        \r\n        // create an analyser node for visualizing the sounds\r\n        this.analyserNode = this.createAnalyser();\r\n        this.analyserNode.connect(this.destination);\r\n        \r\n        // keep track of count of each unique node for id creation\r\n        this.nodeCounts = {\r\n            // store this function and the node count of diff node types in same object\r\n            // use nodeName if supplied\r\n            'addNode': function(node: (\r\n                ExtendedOscillatorNode |\r\n                ExtendedAudioBufferSourceNode |\r\n                ExtendedBiquadFilterNode |\r\n                ExtendedGainNode |\r\n                ADSREnvelope\r\n            )){\r\n                const nodeType = node.constructor.name;\r\n                \r\n                // just keeping count here\r\n                if(this[nodeType]){\r\n                    this[nodeType]++;\r\n                }else{\r\n                    this[nodeType] = 1;\r\n                }\r\n\r\n                return this[nodeType];\r\n            },\r\n            'deleteNode': function(node: (\r\n                ExtendedOscillatorNode |\r\n                ExtendedAudioBufferSourceNode |\r\n                ExtendedBiquadFilterNode |\r\n                ExtendedGainNode |\r\n                ADSREnvelope\r\n            ), nodeName=null){\r\n                const nodeType = node.constructor.name;\r\n                this[nodeType]--;\r\n                return this[nodeType];\r\n            }\r\n        };\r\n        \r\n        // for deciding the ranges and stuff for certain parameter values\r\n        this.valueRanges = {\r\n            \"OscillatorNode\": {\r\n                \"detune\": {\r\n                    \"min\": -1200, \r\n                    \"default\": 0,\r\n                    \"max\": 1200,\r\n                    \"step\": 1\r\n                },\r\n                \"frequency\": {\r\n                    \"min\": 300,\r\n                    \"default\": 440, \r\n                    \"max\": 1000, \r\n                    \"step\": 1\r\n                }\r\n            },\r\n            \"GainNode\": {\r\n                \"gain\": {\r\n                    \"min\": 0, \r\n                    \"default\": 0.3,\r\n                    \"max\": 2,\r\n                    \"step\": 0.05\r\n                }\r\n            },\r\n            \"AudioBufferSourceNode\": {\r\n                \"detune\": {\r\n                    \"min\": -1200, \r\n                    \"default\": 0,\r\n                    \"max\": 1200,\r\n                    \"step\": 1\r\n                }\r\n            },\r\n            \"BiquadFilterNode\": {\r\n                \"gain\": {\r\n                    \"max\": 40,\r\n                    \"min\": -40,\r\n                    \"default\": 0,\r\n                    \"step\": 1\r\n                },\r\n                \"Q\": {\r\n                    \"max\": 1000,\r\n                    \"min\": 0.0001,\r\n                    \"default\": 1,\r\n                    \"step\": .05\r\n                },\r\n                \"detune\": {\r\n                    \"min\": -1200, \r\n                    \"default\": 0,\r\n                    \"max\": 1200,\r\n                    \"step\": 1\r\n                },\r\n                \"frequency\": {\r\n                    \"min\": 300,\r\n                    \"default\": 440, \r\n                    \"max\": 1000, \r\n                    \"step\": 1\r\n                }\r\n            },\r\n            \"ADSREnvelope\": {\r\n                \"attack\": {\r\n                    \"min\": 0,\r\n                    \"default\": 0,\r\n                    \"max\": 1,\r\n                    \"step\": 0.01\r\n                },\r\n                \"sustain\": {\r\n                    \"min\": 0,\r\n                    \"default\": 0,\r\n                    \"max\": 1,\r\n                    \"step\": 0.01\r\n                },\r\n                \"sustainLevel\": {\r\n                    \"min\": 0,\r\n                    \"default\": 0,\r\n                    \"max\": 1,\r\n                    \"step\": 0.01\r\n                },\r\n                \"decay\": {\r\n                    \"min\": 0,\r\n                    \"default\": 0,\r\n                    \"max\": 1,\r\n                    \"step\": 0.01\r\n                },\r\n                \"release\": {\r\n                    \"min\": 0,\r\n                    \"default\": 0,\r\n                    \"max\": 10,\r\n                    \"step\": 0.01\r\n                },\r\n            },\r\n            \"waveType\": [\r\n                \"sine\",\r\n                \"square\",\r\n                \"triangle\",\r\n                \"sawtooth\"\r\n            ],\r\n            \"filterType\": [\r\n                \"lowpass\",\r\n                \"highpass\",\r\n                \"allpass\",\r\n                \"bandpass\",\r\n                \"notch\",\r\n                \"peaking\",\r\n                \"lowshelf\",\r\n                \"highshelf\"\r\n            ],\r\n        }\r\n    } // end constructor\r\n    \r\n    getGainNodes(): AudioStoreNode[] {\r\n        return [...Object.keys(this.nodeStore)]\r\n                .filter((key) => key.indexOf(\"Gain\") >= 0)\r\n                .map((gainId) => this.nodeStore[gainId]);\r\n    }\r\n    \r\n    getOscNodes(): string[] {\r\n        return [...Object.keys(this.nodeStore)]\r\n                .filter((key) => key.indexOf(\"Oscillator\") >= 0 || key.indexOf(\"AudioBuffer\") >= 0);\r\n    }\r\n    \r\n    createAudioContextDestinationUI(parentElement: HTMLElement){\r\n        const audioCtxDest = document.createElement('div');\r\n        audioCtxDest.id = this.destination.constructor.name;\r\n        audioCtxDest.style.border = \"1px solid #000\";\r\n        audioCtxDest.style.borderRadius = \"20px 20px 20px 20px\";\r\n        audioCtxDest.style.padding = \"5px\";\r\n        audioCtxDest.style.width = \"200px\";\r\n        audioCtxDest.style.height = \"200px\";\r\n        audioCtxDest.style.textAlign = \"center\";\r\n        audioCtxDest.style.position = \"absolute\";\r\n        audioCtxDest.style.top = \"20%\";\r\n        audioCtxDest.style.left = \"45%\";\r\n        audioCtxDest.style.zIndex = \"10\";\r\n        \r\n        const title = document.createElement(\"h2\");\r\n        title.textContent = \"audio context destination\";\r\n        audioCtxDest.appendChild(title);\r\n        parentElement.appendChild(audioCtxDest);\r\n    }\r\n    \r\n    // delete all nodes\r\n    reset(){\r\n        const nodeArea = document.getElementById(\"nodeArea\");\r\n        if(nodeArea){\r\n            for(let nodeId in this.nodeStore){\r\n                if(nodeId !== \"AudioDestinationNode\"){\r\n                    this._deleteNode(this.nodeStore[nodeId].node, nodeArea);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    _addBaseValueProp(node: (\r\n        ExtendedOscillatorNode |\r\n        ExtendedAudioBufferSourceNode |\r\n        ExtendedBiquadFilterNode |\r\n        ExtendedGainNode\r\n    )){\r\n        // TODO: TS7053 - need to fix\r\n        for(const prop in node){\r\n            if(node[prop] && node[prop].value){\r\n                node[prop].baseValue = node[prop].value;\r\n            }\r\n        }\r\n        /*\r\n        for(const [propName, value] of Object.entries(node)){\r\n            const nodeProp = value;\r\n            if(nodeProp.value){\r\n                console.log(nodeProp.value);\r\n                nodeProp.baseValue = nodeProp.value;\r\n            }\r\n        }*/\r\n    }\r\n    \r\n    // store a node in this.nodeStore\r\n    _storeNode(node: (\r\n        ExtendedAudioBufferSourceNode | \r\n        ExtendedOscillatorNode | \r\n        ExtendedGainNode | \r\n        ExtendedBiquadFilterNode | \r\n        ADSREnvelope | \r\n        AudioDestinationNode\r\n        ), \r\n        nodeName: string\r\n    ){\r\n        // feedsInto would be an array of strings, where each string is a node's name\r\n        this.nodeStore[nodeName] = {\r\n            'node': node, \r\n            'feedsInto': [],\r\n            'feedsFrom': []\r\n        };\r\n    }\r\n    \r\n    // methods for node creation. I'm thinking of them as 'private' methods because\r\n    // they'll be used in other methods that are more useful and should be called on a NodeFactory instance\r\n    _createWaveNode(): ExtendedOscillatorNode {\r\n        // REMEMBER THAT OSCILLATOR NODES CAN ONLY BE STARTED/STOPPED ONCE!\r\n        // when a note is played multiple times, each time a new oscillator needs to \r\n        // be created. but we can save the properties of the oscillator and reuse that data.\r\n        // so basically we create a dummy oscillator for the purposes of storing information (as a template)\r\n        const osc = this.createOscillator() as ExtendedOscillatorNode; // createOscillator comes from AudioContext\r\n        \r\n        // default params \r\n        osc.frequency.value = 440; // A @ 440 Hz\r\n        osc.detune.value = 0;\r\n        osc.type = \"sine\";\r\n        osc.id = (osc.constructor.name + this.nodeCounts.addNode(osc));\r\n        \r\n        this._addBaseValueProp(osc);\r\n        return osc;\r\n    }\r\n    \r\n    // audio buffer source node\r\n    _createNoiseNode(): ExtendedAudioBufferSourceNode {\r\n        // allow user to pass in the contents of the noise buffer as a list if they want to?\r\n        const noise = this.createBufferSource() as ExtendedAudioBufferSourceNode;\r\n        \r\n        // assign random noise first, but let it be customizable\r\n        const bufSize = this.sampleRate; // customizable?\r\n        const buffer = this.createBuffer(1, bufSize, bufSize);\r\n        \r\n        const output = buffer.getChannelData(0);\r\n        for(let i = 0; i < bufSize; i++){\r\n            output[i] = Math.random() * 2 - 1;\r\n        }\r\n        \r\n        this._addBaseValueProp(noise);\r\n        \r\n        noise.buffer = buffer;\r\n        noise.loop = true;\r\n        noise.id = (noise.constructor.name + this.nodeCounts.addNode(noise));\r\n        return noise;\r\n    }\r\n    \r\n    _createGainNode(): ExtendedGainNode {\r\n        const gainNode = this.createGain() as ExtendedGainNode;\r\n        \r\n        // gain will always need to attach to analyser node (which is connected to destination)\r\n        gainNode.connect(this.analyserNode);\r\n        gainNode.gain.value = this.valueRanges.GainNode.gain.default;\r\n        \r\n        // use this property to remember the desired base volume value\r\n        this._addBaseValueProp(gainNode);\r\n        \r\n        gainNode.id = gainNode.constructor.name + this.nodeCounts.addNode(gainNode);\r\n        return gainNode;\r\n    }\r\n    \r\n    // create a biquadfilter node\r\n    _createBiquadFilterNode(): ExtendedBiquadFilterNode {\r\n        const bqFilterNode = this.createBiquadFilter() as ExtendedBiquadFilterNode;\r\n        \r\n        bqFilterNode.frequency.value = 440;\r\n        bqFilterNode.detune.value = 0;\r\n        bqFilterNode.gain.value = 0;\r\n        bqFilterNode.Q.value = 1;\r\n        bqFilterNode.type = \"lowpass\";\r\n        \r\n        this._addBaseValueProp(bqFilterNode);\r\n        \r\n        // need to add to nodeCounts\r\n        bqFilterNode.id = bqFilterNode.constructor.name + this.nodeCounts.addNode(bqFilterNode);\r\n        return bqFilterNode;\r\n    }\r\n    \r\n    // attack, decay, sustain, release envelope node\r\n    // this will target the params of another node like Oscillator or BiquadFilter or Gain \r\n    // for now we should keep this very simple! :)\r\n    _createADSREnvelopeNode(): ADSREnvelope {\r\n        const envelope = new ADSREnvelope();\r\n        envelope.id = \"ADSREnvelope\" + this.nodeCounts.addNode(envelope);\r\n        return envelope;\r\n    }\r\n    \r\n    _deleteNode(node: (\r\n        ExtendedAudioBufferSourceNode | \r\n        ExtendedOscillatorNode | \r\n        ExtendedGainNode | \r\n        ExtendedBiquadFilterNode | \r\n        ADSREnvelope\r\n    ), nodeArea: HTMLElement){\r\n        const nodeName = node.id;\r\n        const nodeToDelete = this.nodeStore[nodeName].node;\r\n        \r\n        // decrement count \r\n        this.nodeCounts.deleteNode(node);\r\n        \r\n        // unhook all connections in the UI\r\n        const connectionsTo = this.nodeStore[nodeName].feedsInto;\r\n        if(connectionsTo){\r\n            connectionsTo.forEach((connection) => {\r\n                // remove the UI representation of the connection\r\n                const svg = document.getElementById(\"svgCanvas:\" + nodeName + \":\" + connection);\r\n                if(svg){\r\n                    nodeArea.removeChild(svg);\r\n                }\r\n                \r\n                // also remove the reference of the node being deleted from this connected node's feedsFrom\r\n                const targetFeedsFrom = this.nodeStore[connection].feedsFrom;\r\n                this.nodeStore[connection].feedsFrom = targetFeedsFrom.filter(node => node !== nodeName);\r\n            });\r\n        }\r\n        \r\n        const connectionsFrom = this.nodeStore[nodeName].feedsFrom;\r\n        if(connectionsFrom){\r\n            connectionsFrom.forEach((connection) => {\r\n                const svg = document.getElementById(\"svgCanvas:\" + connection + \":\" + nodeName);\r\n                if(svg){\r\n                    nodeArea.removeChild(svg);\r\n                }\r\n                \r\n                // also remove the reference of the node being deleted from this connected node's feedsInto\r\n                const targetFeedsInto = this.nodeStore[connection].feedsInto;\r\n                this.nodeStore[connection].feedsInto = targetFeedsInto.filter(node => node !== nodeName);\r\n            });\r\n        }\r\n        \r\n        // remove it \r\n        delete this.nodeStore[nodeName];\r\n        \r\n        // clear UI\r\n        const nodeElement = document.getElementById(nodeName);\r\n        if(nodeElement){\r\n            nodeArea.removeChild(nodeElement);\r\n        }\r\n    }\r\n    \r\n    _addNodeToInterface(node: (\r\n            ExtendedAudioBufferSourceNode |\r\n            ExtendedOscillatorNode |\r\n            ExtendedGainNode |\r\n            ExtendedBiquadFilterNode |\r\n            ADSREnvelope\r\n        ),\r\n        nodeArea: HTMLElement,\r\n        x='100px', \r\n        y='100px'\r\n    ){\r\n        // place randomly in designated area?\r\n        const uiElement = this._createNodeUIElement(node);\r\n        uiElement.style.top = x;\r\n        uiElement.style.left = y;\r\n        nodeArea.appendChild(uiElement);\r\n    }\r\n    \r\n    _createNodeUIElement(node: (\r\n        ExtendedAudioBufferSourceNode |\r\n        ExtendedOscillatorNode |\r\n        ExtendedGainNode |\r\n        ExtendedBiquadFilterNode |\r\n        ADSREnvelope\r\n    )){\r\n        // add event listener to allow it to be hooked up to another node if possible\r\n        const uiElement = document.createElement('div');\r\n        uiElement.style.backgroundColor = \"#fff\";\r\n        uiElement.style.zIndex = \"10\";\r\n        uiElement.style.position = 'absolute';\r\n        uiElement.style.border = '1px solid #000';\r\n        uiElement.style.borderRadius = '20px 20px 20px 20px';\r\n        uiElement.style.padding = '5px';\r\n        uiElement.style.textAlign = 'center';\r\n        uiElement.classList.add(\"nodeElement\");\r\n        uiElement.id = node.id;\r\n        \r\n        const nodeInfo = this.nodeStore[node.id];\r\n        \r\n        uiElement.addEventListener(\"mousedown\", (evt: MouseEvent) => {\r\n            const offsetX = evt.clientX - uiElement.offsetLeft + window.pageXOffset;\r\n            const offsetY = evt.clientY - uiElement.offsetTop + window.pageYOffset;\r\n    \r\n            function moveHelper(x: number, y: number){\r\n                uiElement.style.left = (x + 'px');\r\n                uiElement.style.top = (y + 'px');\r\n                \r\n                if(nodeInfo.feedsInto){\r\n                    nodeInfo.feedsInto.forEach((connection: string) => {\r\n                        const svg = document.getElementById(\"svgCanvas:\" + uiElement.id + \":\" + connection);\r\n                        if(svg !== null){\r\n                            document.getElementById(\"nodeArea\")!.removeChild(svg);\r\n                        }\r\n                        const connect = document.getElementById(connection);\r\n                        if(connect !== null){\r\n                            if(uiElement.id.indexOf(\"ADSR\") >= 0){\r\n                                drawLineBetween(uiElement, connect, true);\r\n                            }else{\r\n                                drawLineBetween(uiElement, connect);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                \r\n                if(nodeInfo.feedsFrom){\r\n                    nodeInfo.feedsFrom.forEach((connection: string) => {\r\n                        const svg = document.getElementById(\"svgCanvas:\" + connection + \":\" + uiElement.id);\r\n                        if(svg !== null){\r\n                            document.getElementById(\"nodeArea\")!.removeChild(svg);\r\n                        }\r\n                        const connect = document.getElementById(connection);\r\n                        if(connect !== null){\r\n                            if(connection.indexOf(\"ADSR\") >= 0){\r\n                                drawLineBetween(connect, uiElement, true);\r\n                            }else{\r\n                                drawLineBetween(connect, uiElement);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n    \r\n            function moveNode(evt: MouseEvent){\r\n                evt.stopPropagation();\r\n                if(!(<HTMLElement>evt.target)!.classList.contains(\"nodeElement\")){\r\n                    return;\r\n                }\r\n                moveHelper((evt.pageX - offsetX), (evt.pageY - offsetY));\r\n            }\r\n            \r\n            document.addEventListener(\"mousemove\", moveNode);\r\n            \r\n            uiElement.addEventListener(\"mouseup\", (evt: MouseEvent) => {\r\n                document.removeEventListener(\"mousemove\", moveNode);\r\n            });\r\n        });\r\n        \r\n        uiElement.addEventListener('dblclick', (evt: MouseEvent) => {\r\n            // display menu for this node to edit params \r\n            showParameterEditWindow(nodeInfo, this.valueRanges);\r\n        });\r\n        \r\n        // add the name of the node\r\n        const name = document.createElement('h4');\r\n        name.textContent = node.id;\r\n        uiElement.appendChild(name);\r\n        \r\n        // connect-to-other-nodes functionality \r\n        const connectButton = document.createElement('button');\r\n        connectButton.textContent = \"connect to another node\";\r\n        connectButton.addEventListener(\"click\", (evt) => {\r\n            function selectNodeToConnectHelper(\r\n                evt: MouseEvent, \r\n                source: HTMLElement,\r\n                nodeStore: Record<string, AudioStoreNode>\r\n            ){\r\n                let target = <HTMLElement>evt.target;\r\n                if(target && !target.classList.contains(\"nodeElement\") && target.parentNode){\r\n                    target = target.parentNode as HTMLElement;\r\n                }\r\n                \r\n                // if the target is still not a node element, return\r\n                if(target && !target.classList.contains(\"nodeElement\")){\r\n                    return; \r\n                }\r\n                \r\n                // if the target does not accept inputs (using the built-in numberOfInputs prop),\r\n                // also return\r\n                if(nodeStore[target.id].node.numberOfInputs < 1){\r\n                    return;\r\n                }\r\n                \r\n                target.style.backgroundColor = \"#fff\";\r\n                \r\n                // update node's connections in nodeStore\r\n                // store the target, or the sink for this source, html id \r\n                // make it a bidrectional graph -> the node that gets fed \r\n                // should also know the nodes that feed into it.\r\n                const sourceConnections = nodeStore[source.id];\r\n                sourceConnections[\"feedsInto\"].push(target.id);\r\n                \r\n                const destConnections = nodeStore[target.id];\r\n                destConnections[\"feedsFrom\"].push(source.id);\r\n                \r\n                // update UI to show link between nodes\r\n                if(source.id.indexOf(\"ADSR\") >= 0){\r\n                    drawLineBetween(source, target, true);\r\n                }else{\r\n                    drawLineBetween(source, target);\r\n                }\r\n                \r\n                // remove the event listeners needed to form the new connection \r\n                // from all the nodes\r\n                [...Object.keys(nodeStore)].forEach((node) => {\r\n                    if(node !== source.id){\r\n                        const otherNode = document.getElementById(node);\r\n                        if(otherNode !== null){\r\n                            otherNode.removeEventListener(\"mouseover\", mouseoverNode);\r\n                            otherNode.removeEventListener(\"mouseleave\", mouseleaveNode);\r\n                            otherNode.removeEventListener(\"click\", selectNodeToConnectTo);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            \r\n            const nodeStore = this.nodeStore;\r\n            function selectNodeToConnectTo(evt: MouseEvent){\r\n                selectNodeToConnectHelper(evt, uiElement, nodeStore);\r\n            }\r\n            \r\n            function mouseoverNode(evt: MouseEvent){\r\n                // highlight the node being hovered over\r\n                if((<HTMLElement>evt.target)!.classList.contains(\"nodeElement\")){\r\n                    (<HTMLElement>evt.target).style.backgroundColor = \"#ffcccc\";\r\n                }\r\n            }\r\n            \r\n            function mouseleaveNode(evt: MouseEvent){\r\n                if((<HTMLElement>evt.target)!.classList.contains(\"nodeElement\")){\r\n                    (<HTMLElement>evt.target).style.backgroundColor = \"#fff\";\r\n                }\r\n            }\r\n            \r\n            function cancelConnectionHelper(\r\n                evt: Event, \r\n                source: HTMLElement, \r\n                nodeStore: Record<string, AudioStoreNode>\r\n            ){\r\n                evt.preventDefault();\r\n                [...Object.keys(nodeStore)].forEach((node) => {\r\n                    if(node !== source.id){\r\n                        const otherNode = document.getElementById(node);\r\n                        if(otherNode !== null){\r\n                            otherNode.removeEventListener(\"mouseover\", mouseoverNode);\r\n                            otherNode.removeEventListener(\"mouseleave\", mouseleaveNode);\r\n                            otherNode.removeEventListener(\"click\", selectNodeToConnectTo);\r\n                            otherNode.style.backgroundColor = \"#fff\";\r\n                        }\r\n                    }\r\n                });\r\n                document.body.removeEventListener(\"contextmenu\", cancelConnection);\r\n            }\r\n            \r\n            function cancelConnection(evt: Event){\r\n                cancelConnectionHelper(evt, uiElement, nodeStore);\r\n            }\r\n            document.body.addEventListener(\"contextmenu\", cancelConnection);\r\n            \r\n            // TODO: set up rules to determine which kinds of nodes this one can feed into!\r\n            // add an event listener for all node elements that this node could connect with \r\n            [...Object.keys(nodeStore)].forEach((node) => {\r\n                if(node !== uiElement.id){            \r\n                    const otherNode = document.getElementById(node);\r\n                    if(otherNode !== null){\r\n                        otherNode.addEventListener(\"mouseover\", mouseoverNode);\r\n                        otherNode.addEventListener(\"mouseleave\", mouseleaveNode);\r\n                        otherNode.addEventListener(\"click\", selectNodeToConnectTo);\r\n                    }\r\n                }\r\n            })\r\n        });\r\n        uiElement.appendChild(connectButton);\r\n        uiElement.appendChild(document.createElement('br'));\r\n        \r\n        // delete node functionality\r\n        const deleteButton = document.createElement('button');\r\n        deleteButton.textContent = \"delete\";\r\n        deleteButton.addEventListener('click', (evt) => {\r\n            const nodeArea = document.getElementById(\"nodeArea\");\r\n            if(nodeArea){\r\n                this._deleteNode(node, nodeArea);\r\n            }\r\n        });\r\n        \r\n        uiElement.appendChild(deleteButton);\r\n        \r\n        return uiElement;\r\n    }\r\n    \r\n    // create and add a new wave node to the interface\r\n    addNewNode(nodeType: NodeTypes, addToInterface=true){\r\n        // create the node object\r\n        let newNode = null;\r\n        \r\n        if(nodeType === \"waveNode\"){\r\n            newNode = this._createWaveNode();\r\n        }else if(nodeType === \"biquadFilterNode\"){\r\n            newNode = this._createBiquadFilterNode();\r\n        }else if(nodeType === \"noiseNode\"){\r\n            newNode = this._createNoiseNode();\r\n        }else if(nodeType === \"gainNode\"){\r\n            newNode = this._createGainNode();\r\n        }else if(nodeType === \"ADSREnvelope\"){\r\n            newNode = this._createADSREnvelopeNode();\r\n        }else{\r\n            console.log(\"unknown node type!\");\r\n            return;\r\n        }\r\n        \r\n        // store it \r\n        this._storeNode(newNode, newNode.id);\r\n        \r\n        // TODO: this should be a separate function?\r\n        const nodeArea = document.getElementById('nodeArea');\r\n        if(addToInterface && nodeArea) this._addNodeToInterface(newNode, nodeArea);\r\n        \r\n        if(nodeType === \"gainNode\"){\r\n            // gain node is special :)\r\n            const audioCtx = this.destination.constructor.name;\r\n            this.nodeStore[newNode.id][\"feedsInto\"] = [audioCtx];\r\n            this.nodeStore[audioCtx][\"feedsFrom\"].push(newNode.id);\r\n            \r\n            const src = document.getElementById(newNode.id);\r\n            const dest = document.getElementById(audioCtx);\r\n            if(src && dest){\r\n                drawLineBetween(src, dest); // order matters! :0\r\n            }\r\n        }\r\n    }\r\n    \r\n} // end NodeFactory", "import { NodeFactory } from \"./NodeFactory\";\r\nimport { ADSREnvelope } from \"./ADSREnvelope\";\r\nimport { ExtendedGainNode, AudioStoreNode } from \"./types\";\r\nimport {\r\n    exportPreset,\r\n    importPreset,\r\n    loadDemoPreset\r\n} from \"./utils\";\r\n\r\nconst NOTE_FREQ: Record<string, number> = {\r\n    \"C8\": 4186.01,\r\n    \"B7\": 3951.07,\r\n    \"Bb7\": 3729.31,\r\n    \"A#7\": 3729.31,\r\n    \"A7\": 3520.00,\r\n    \"Ab7\": 3322.44,\r\n    \"G#7\": 3322.44,\r\n    \"G7\": 3135.96,\r\n    \"Gb7\": 2959.96,\r\n    \"F#7\": 2959.96,\r\n    \"F7\": 2793.83,\r\n    \"E7\": 2637.02,\r\n    \"Eb7\": 2489.02,\r\n    \"D#7\": 2489.02,\r\n    \"D7\": 2349.32,\r\n    \"Db7\": 2217.46,\r\n    \"C#7\": 2217.46,\r\n\r\n    \"C7\": 2093.00,\r\n    \"B6\": 1975.53,\r\n    \"Bb6\": 1864.66,\r\n    \"A#6\": 1864.66,\r\n    \"A6\": 1760.00,\r\n    \"Ab6\": 1661.22,\r\n    \"G#6\": 1661.22,\r\n    \"G6\": 1567.98,\r\n    \"Gb6\": 1479.98,\r\n    \"F#6\": 1479.98,\r\n    \"F6\": 1396.91,\r\n    \"E6\": 1318.51,\r\n    \"Eb6\": 1244.51,\r\n    \"D#6\": 1244.51,\r\n    \"D6\": 1174.66,\r\n    \"Db6\": 1108.73,\r\n    \"C#6\": 1108.73,\r\n    \"C6\": 1046.50,\r\n\r\n    \"B5\": 987.77,\r\n    \"Bb5\": 932.33,\r\n    \"A#5\": 932.33,\r\n    \"A5\": 880.00,\r\n    \"Ab5\": 830.61,\r\n    \"G#5\": 830.61,\r\n    \"G5\": 783.99,\r\n    \"Gb5\": 739.99,\r\n    \"F#5\": 739.99,\r\n    \"F5\": 698.46,\r\n    \"E5\": 659.25,\r\n    \"Eb5\": 622.25,\r\n    \"D#5\": 622.25,\r\n    \"D5\": 587.33,\r\n    \"Db5\": 554.37,\r\n    \"C#5\": 554.37,\r\n    \"C5\": 523.25,\r\n\r\n    \"B4\": 493.88,\r\n    \"Bb4\": 466.16,\r\n    \"A#4\": 466.16,\r\n    \"A4\": 440.00,\r\n    \"Ab4\": 415.30,\r\n    \"G#4\": 415.30,\r\n    \"G4\": 392.00,\r\n    \"Gb4\": 369.99,\r\n    \"F#4\": 369.99,\r\n    \"F4\": 349.23,\r\n    \"E4\": 329.63,\r\n    \"Eb4\": 311.13,\r\n    \"D#4\": 311.13,\r\n    \"D4\": 293.66,\r\n    \"Db4\": 277.18,\r\n    \"C#4\": 277.18,\r\n    \"C4\": 261.63,\r\n    \r\n    \"B3\": 246.94,\r\n    \"Bb3\": 233.08,\r\n    \"A#3\": 233.08,\r\n    \"A3\": 220.00,\r\n    \"Ab3\": 207.63,\r\n    \"G#3\": 207.63,\r\n    \"G3\": 196.00,\r\n    \"Gb3\": 185.00,\r\n    \"F#3\": 185.00,\r\n    \"F3\": 174.61,\r\n    \"E3\": 164.81,\r\n    \"Eb3\": 155.56,\r\n    \"D#3\": 155.56,\r\n    \"D3\": 146.83,\r\n    \"Db3\": 138.59,\r\n    \"C#3\": 138.59,\r\n    \"C3\": 130.81,\r\n    \r\n    \"B2\": 123.47,\r\n    \"Bb2\": 116.54,\r\n    \"A#2\": 116.54,\r\n    \"A2\": 110.00,\r\n    \"Ab2\": 103.83,\r\n    \"G#2\": 103.83,\r\n    \"G2\": 98.00,\r\n    \"Gb2\": 92.50,\r\n    \"F#2\": 92.50,\r\n    \"F2\": 87.31,\r\n    \"E2\": 82.41,\r\n    \"Eb2\": 77.78,\r\n    \"D#2\": 77.78,\r\n    \"D2\": 73.42,\r\n    \"Db2\": 69.30,\r\n    \"C#2\": 69.30,\r\n    \"C2\": 65.41\r\n};\r\n\r\n// maybe move all the UI handling stuff to another class that will be comprised of the nodefactory class?\r\nclass SoundMaker {\r\n    nodeFactory: NodeFactory;\r\n    \r\n    constructor(){\r\n        this.nodeFactory = new NodeFactory();\r\n        this.nodeFactory.suspend(); // need to suspend audio context (which a node factory is) initially\r\n        \r\n        // store the audio context's destination as a node\r\n        this.nodeFactory._storeNode(\r\n            this.nodeFactory.destination, \r\n            this.nodeFactory.destination.constructor.name\r\n        );\r\n    }\r\n}\r\n\r\nfunction processNote(noteFreq: number, nodeFactory: NodeFactory): OscillatorNode[] {\r\n    // this is used to create and use new nodes each time a note needs to be played\r\n    const nodeStore = nodeFactory.nodeStore;\r\n\r\n    // probably should look at not just osc nodes but those with 0 input.\r\n    // i.e. OscillatorNodes, AudioBufferSourceNodes\r\n    const oscNodes = nodeFactory.getOscNodes();\r\n    \r\n    const nodesToStart : OscillatorNode[] = [];\r\n    oscNodes.forEach((osc) => {\r\n        // create a new osc node from the template props\r\n        const oscTemplateNode = nodeStore[osc].node;\r\n        const templateProps: Record<string, any> = {};\r\n        \r\n        // TODO: do we really need to extract values for AudioParams like this?\r\n        Object.keys(Object.getPrototypeOf(oscTemplateNode)).forEach((propName) => {\r\n            const prop = oscTemplateNode[propName];\r\n            templateProps[propName] = (prop.value !== undefined) ? prop.value : prop;\r\n            \r\n            if(propName === \"frequency\"){\r\n                templateProps[propName] = noteFreq;\r\n            }\r\n        });\r\n        \r\n        // the audio node constructors are accessible via the window object\r\n        // TODO: try solving TS2351? (don't cast window as any)\r\n        const newOsc = new ((window as any)[oscTemplateNode.constructor.name])(nodeFactory, templateProps);\r\n        nodesToStart.push(newOsc);\r\n        \r\n        // need to go down all the way to each node and make connections\r\n        // gain nodes don't need to be touched as they're already attached to the context dest by default\r\n        const connections = nodeStore[osc].feedsInto;\r\n        connections.forEach((conn) => {\r\n            // connect the new osc node to this node which will act as a sink (the new osc -> this node)\r\n            const sinkNode = nodeStore[conn].node;\r\n            \r\n            newOsc.connect(sinkNode);\r\n            \r\n            // if sink is a gain node, no need to go further\r\n            if(sinkNode.id.indexOf(\"Gain\") < 0){\r\n                let stack: string[] = nodeStore[sinkNode.id][\"feedsInto\"];\r\n                let newSource = sinkNode;\r\n                \r\n                while(stack.length > 0){\r\n                    const next = stack.pop() as string;\r\n                    const currSink = nodeStore[next].node;\r\n                    console.log(\"connecting: \" + newSource.constructor.name + \" to: \" + currSink.constructor.name);\r\n                    \r\n                    newSource.connect(currSink);\r\n                    newSource = currSink;\r\n                    const nextConnections = nodeStore[next][\"feedsInto\"].filter((name: string) => name.indexOf(\"Destination\") < 0);\r\n                    stack = stack.concat(nextConnections);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    \r\n    const time = nodeFactory.currentTime;\r\n    const gainNodes = nodeFactory.getGainNodes();\r\n\r\n    gainNodes.forEach((gain) => {\r\n        // we need to understand the distinction of connecting to another node vs. connecting to an AudioParam of another node!\r\n        // maybe use dotted lines?\r\n        const gainNode = gain.node;\r\n        const adsr = getADSRFeed(gain);\r\n        if(adsr){\r\n            // if an adsr envelope feeds into this gain node, run the adsr function on the gain\r\n            const envelope = nodeStore[adsr].node;\r\n            envelope.applyADSR(gainNode.gain, time);\r\n        }else{\r\n            gainNode.gain.setValueAtTime(gainNode.gain.value, time);\r\n        }\r\n    });\r\n    \r\n    return nodesToStart;\r\n}\r\n\r\nfunction getADSRFeed(sinkNode: AudioStoreNode): string | null {\r\n    // check if sinkNode has an ADSR envelope\r\n    const feedsFrom = sinkNode.feedsFrom;\r\n    for(let i = 0; i < feedsFrom.length; i++){\r\n        const source = feedsFrom[i];\r\n        if(source.indexOf(\"ADSR\") >= 0){\r\n            return source; // return name of ADSR envelope\r\n        }\r\n    };\r\n    return null;\r\n}\r\n\r\nfunction setupButtons(){\r\n    document.getElementById('addWavNode')!.addEventListener('click', (evt: MouseEvent) => {\r\n        soundMaker.nodeFactory.addNewNode(\"waveNode\");\r\n    });\r\n\r\n    document.getElementById('addGainNode')!.addEventListener('click', (evt: MouseEvent) => {\r\n        soundMaker.nodeFactory.addNewNode(\"gainNode\");\r\n    });\r\n\r\n    document.getElementById('addNoiseNode')!.addEventListener('click', (evt: MouseEvent) => {\r\n        soundMaker.nodeFactory.addNewNode(\"noiseNode\");\r\n    });\r\n\r\n    document.getElementById('addFilterNode')!.addEventListener('click', (evt: MouseEvent) => {\r\n        soundMaker.nodeFactory.addNewNode(\"biquadFilterNode\");\r\n    });\r\n\r\n    document.getElementById('addADSRNode')!.addEventListener('click', (evt: MouseEvent) => {\r\n        soundMaker.nodeFactory.addNewNode(\"ADSREnvelope\");\r\n    });\r\n\r\n    document.getElementById('download')!.addEventListener('click', (evt: MouseEvent) => {\r\n        exportPreset(soundMaker.nodeFactory);\r\n    });\r\n\r\n    document.getElementById('import')!.addEventListener('click', (evt: MouseEvent) => {\r\n        importPreset(soundMaker.nodeFactory);\r\n    });\r\n\r\n    document.getElementById('demos')!.addEventListener('change', (evt: Event) => {\r\n        const selectElement = <HTMLSelectElement>evt.target;\r\n        const presetName = selectElement.options[selectElement.selectedIndex].value;\r\n        if(presetName !== \"\"){\r\n            loadDemoPreset(presetName, soundMaker.nodeFactory);\r\n        }\r\n    });\r\n\r\n    document.getElementById('toggleViz')!.addEventListener('click', (evt: MouseEvent) => {\r\n        //const style = window.getComputedStyle(e.target);\r\n        //console.log(style.getPropertyValue('border'));\r\n        const borderStyle = (<HTMLElement>evt.target).style.border;\r\n        if(!borderStyle || borderStyle === '3px solid rgb(0, 204, 0)'){\r\n            (<HTMLElement>evt.target).style.border = '3px solid rgb(204, 0, 0)';\r\n            (<HTMLElement>evt.target).textContent = 'off';\r\n            \r\n            // stop visualization\r\n            window.cancelAnimationFrame(doVisualization);\r\n            \r\n            // clear canvas\r\n            canvasCtx!.clearRect(0, 0, canvas.width, canvas.height);\r\n        }else{\r\n            (<HTMLElement>evt.target).style.border = '3px solid rgb(0, 204, 0)';\r\n            (<HTMLElement>evt.target).textContent = 'on';\r\n            \r\n            // start visualization\r\n            doVisualization = requestAnimationFrame(runViz);\r\n        }\r\n    });\r\n}\r\n\r\n\r\n\r\n//////////////// SET UP  ///////////////////\r\nconst soundMaker = new SoundMaker();\r\nconst notes = [...document.getElementsByClassName(\"note\")] as SVGElement[];\r\nlet currPlayingNodes : OscillatorNode[] = [];\r\n\r\nsetupButtons();\r\nsoundMaker.nodeFactory.createAudioContextDestinationUI(document.getElementById(\"nodeArea\")!);\r\n\r\n\r\n// set up the keyboard for playing notes\r\nfunction setupKeyboard(notes: SVGElement[], nodeFactory: NodeFactory){\r\n    const audioContext = nodeFactory;\r\n    \r\n    function stopPlay(evt: MouseEvent){\r\n        if(evt.target){\r\n            (<HTMLElement>evt.target).style.stroke = \"#000000\";\r\n            (<HTMLElement>evt.target).style.strokeWidth = \"0.264583px\";\r\n        }\r\n        \r\n        let maxEndTime = audioContext.currentTime;\r\n        \r\n        // apply adsr release, if any\r\n        const gainNodes = nodeFactory.getGainNodes();\r\n        gainNodes.forEach((gain) => {\r\n            const gainNode = <ExtendedGainNode>gain.node;\r\n            const adsr = getADSRFeed(gain);\r\n            if(adsr){\r\n                const envelope = <ADSREnvelope>nodeFactory.nodeStore[adsr].node;\r\n                gainNode.gain.linearRampToValueAtTime(0.0, audioContext.currentTime + envelope.release);\r\n                maxEndTime = Math.max(audioContext.currentTime + envelope.release, maxEndTime);\r\n                \r\n                // also reset gain value back to whatever it's currently set at\r\n                gainNode.gain.setValueAtTime(gainNode.gain.baseValue, audioContext.currentTime + envelope.release + 0.01);\r\n            }else{\r\n                // slightly buggy: if you remove an ADSR envelope, the next time a note is played the gain value will be at\r\n                // wherever the ADSR left off (but after that the volume will be correct as it'll use the base value)\r\n                // maybe we should fix gain stuff on mousedown instead?\r\n                gainNode.gain.setValueAtTime(gainNode.gain.baseValue, audioContext.currentTime);\r\n            }\r\n        });\r\n\r\n        currPlayingNodes.forEach((osc) => {\r\n            osc.stop(maxEndTime);\r\n        });\r\n    }\r\n    \r\n    notes.forEach((note) => {\r\n        note.addEventListener('mouseleave', stopPlay);\r\n        note.addEventListener('mouseup', stopPlay);\r\n        note.addEventListener('mousedown', (evt) => {\r\n            // highlight the key outline on the svg keyboard when pressed\r\n            if(evt.buttons === 1){\r\n                (<SVGElement>evt.target).style.stroke = \"#2470FC\";\r\n                (<SVGElement>evt.target).style.strokeWidth = \"0.6px\";\r\n                audioContext.resume().then(() => {\r\n                    const noteFreq = NOTE_FREQ[note.id + (<HTMLInputElement>document.getElementById('octaveSelect')).value];\r\n                    currPlayingNodes = processNote(noteFreq, nodeFactory);\r\n                    currPlayingNodes.forEach((osc) => {\r\n                        osc.start(0);\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    });\r\n}\r\nsetupKeyboard(notes, soundMaker.nodeFactory);\r\n\r\n\r\n// setup for audio visualization\r\n// TODO: do something about these global variables? kinda messy\r\nsoundMaker.nodeFactory.analyserNode.fftSize = 2048;\r\nconst bufferLen: number = soundMaker.nodeFactory.analyserNode.frequencyBinCount;\r\nconst dataArray = new Uint8Array(bufferLen);\r\n\r\nconst canvas: HTMLCanvasElement = document.getElementById('vizCanvas') as HTMLCanvasElement;\r\nconst canvasCtx = canvas!.getContext('2d');\r\ncanvasCtx!.clearRect(0, 0, canvas!.width, canvas!.height);\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\r\nlet doVisualization: number = requestAnimationFrame(runViz); // keep the request id around to be able to cancel if needed\r\nfunction runViz(){\r\n    const width = (canvas as HTMLCanvasElement).width;\r\n    const height = (canvas as HTMLCanvasElement).height;\r\n    \r\n    if(canvasCtx){\r\n        soundMaker.nodeFactory.analyserNode.getByteTimeDomainData(dataArray);\r\n        canvasCtx.fillStyle = 'rgb(200, 200, 200)';\r\n        canvasCtx.fillRect(0, 0, width, height);\r\n        canvasCtx.lineWidth = 2;\r\n        canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\r\n        canvasCtx.beginPath();\r\n        \r\n        const sliceWidth = width / bufferLen;\r\n        let xPos = 0;\r\n        \r\n        for(let i = 0; i < bufferLen; i++){\r\n            const dataVal = dataArray[i] / 128.0; // why 128?\r\n            const yPos = dataVal * (height/2);\r\n            \r\n            if(i === 0){\r\n                canvasCtx!.moveTo(xPos, yPos);\r\n            }else{\r\n                canvasCtx!.lineTo(xPos, yPos);\r\n            }\r\n            \r\n            xPos += sliceWidth;\r\n        }\r\n        \r\n        canvasCtx.stroke();\r\n        \r\n        doVisualization = requestAnimationFrame(runViz);\r\n    }\r\n}\r\n\r\n\r\n///////// TESTS\r\n// TODO: move to separate file\r\nfunction Test1(){\r\n    let sm = new SoundMaker();\r\n    console.log(sm.nodeFactory !== undefined);\r\n    \r\n    let nf = sm.nodeFactory;\r\n    nf.addNewNode(\"waveNode\", false); \r\n    console.log(Object.keys(nf.nodeStore).length === 1);\r\n    console.log(Object.keys(nf.nodeStore)[0] === \"OscillatorNode1\");\r\n    console.log(nf.nodeCounts[\"OscillatorNode\"] === 1);\r\n}\r\n//Test1();\r\n"],
  "mappings": "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",
  "names": []
}
